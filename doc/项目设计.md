# 夏季学期应用大作业—12组项目设计

## 1.项目名称

CV WEB：面向高级模型用户的 CV 模型应用管理平台

## 2.项目背景

### 2.2.应用场景

​	随着以深度学习为代表的人工智能技术，特别是在计算机视觉（CV）领域的发展，各类模型已经广泛应用于各行各业。许多人工智能（AI）模型的生产厂家都会开发平台，提供接口供模型使用者调用，使他们能方便地使用模型。然而，模型程序员在开发和调试模型的过程中，仍然需要处理许多重复工作，如数据预处理、数据后处理和数据可视化等。这些任务占用了他们大量的时间和精力，而这些工作可以通过模块化的方式加以简化和优化。

​	当前，许多模型应用平台主要面向模型的最终用户（初级用户），而模型程序员（专业用户）则主要通过编写代码来实现诸如数据处理、可视化以及超参配置的功能。本项目旨在开发一个面向模型程序员的模块化平台，将常见的可复用工作进行封装，减少跨项目复用的成本，并提供良好的可视化和交互界面。这样，模型程序员可以更专注于模型本身的开发和优化工作，提高工作效率。

<img src=".figure/1.png" alt="1" style="zoom: 50%;" />

### 2.3.面向用户

​	本平台主要面向拥有一定机器学习模型相关知识的高级、专业用户组成的个人或小型研究团队。为他们提供一个基于项目文件的管理、调度和可视化平台。通过良好的交互性、模块化设计、用户透明原则和优秀的可视化功能减轻用户负担，帮助用户将更多的精力集中于策略开发上。

### 2.4.相关工作

​	在当前的技术环境中，有一些平台已经在为模型程序员和开发人员提供支持，这些平台在功能和用户体验方面各有特色。以下是几个典型的相关工作：

1. [**Stable Diffusion Web UI 平台**](https://stabledifffusion.com/webui)：Stable Diffusion Web UI 是一个主要面向图像生成和处理的Web平台。它允许用户使用预训练的模型进行图像生成和编辑。虽然该平台为高级用户提供了许多直观的功能，但其在专业用户需求的支持上仍有所欠缺。它更多地专注于用户友好的界面和基本功能的实现，而不是深度定制和扩展。
2. [**TensorFlow Extended (TFX)**]([TFX | TensorFlow中文官网 (google.cn)](https://tensorflow.google.cn/tfx?hl=zh-cn))：TFX 是一个端到端的平台，专门用于生产环境中的机器学习模型。它提供了一整套用于构建和管理机器学习流水线的工具，包括数据验证、特征工程、模型训练、模型评估和模型部署等。TFX 的模块化设计虽然适合专业的模型程序员，但配置和使用过程中涉及的技术细节繁多，增加了开发的时间成本和学习成本。此外，TFX 偏重于生产环境中的部署和管理，对于开发过程中需要频繁调试和快速迭代的场景支持不足。
3. [**MLflow**]([MLflow | MLflow](https://mlflow.org/))：MLflow 是一个开源平台，旨在管理机器学习的全生命周期。它支持实验跟踪、项目管理、模型管理和模型部署。虽然其开放性和灵活性使其成为许多数据科学团队的首选工具，但其用户界面相对简陋，缺乏直观的可视化功能。MLflow 更适合有经验的开发人员使用，对于初级用户或需要复杂可视化支持的场景，可能显得不够友好和直观
4. [**PaddlePaddle (百度飞桨)**](https://www.paddlepaddle.org.cn/))：PaddlePaddle 是百度开源的深度学习平台，具有高效的训练和推理能力。尽管 PaddlePaddle 提供了一些高层 API 和工具，其在可视化界面上也做出了重要尝试，但其平台仍然较为简陋和不稳定，缺乏针对性的模块化开发和调试工具。
5. [**KubeFlow**]([Kubeflow](https://www.kubeflow.org/))：KubeFlow 是一个基于 Kubernetes 的开源平台，专为机器学习工作流的管理而设计。尽管 KubeFlow 提供了强大的分布式计算能力，但其部署和管理过程较为复杂，对基础设施的要求较高。对于需要灵活、快速开发和迭代的场景，KubeFlow 的配置和维护成本较高，不太适合个人开发者或小型团队。



## 3.总体设计

### 3.1.项目环境

- 深度学习开发框架：PaddlePaddle
- 系统：Windows 10、Linux
- 用户文件语言：python
- 项目后端语言/框架：待定
- 项目前端框架：next.js

### 3.2.系统协议

#### 3.2.1.系统特点与设计理念

​	CV-WEB 平台是以 CV 领域的深度学习项目为预设设计的脚本管理系统，但鉴于其优秀的模块化和透明设计，CV-WEB的实际功能非常强大（同时也很弱小），其实际应用领域并不限制于 CVDL 项目。就目前的版本而言，只要满足文件和函数规范的所有项目都可以被 CV-WEB 对接（要不我们后面改个名字吧hh）

#### 3.2.2.项目、任务与策略

​	CV-WEB 通过 `项目` 区分独立的用户工作；每个项目在原则上由多个 `任务` 组成，用户通过组织和完成 `任务` 实现完成项目的目的；`任务`  的实现方式被称为 `策略`，它们的详细含义如下：

- **项目**：项目的文件表示是用户与我们的系统管理层包 `CVWEB` 放置在同一级目录下的文件夹，每个文件夹都被视作一个独立的项目，例如：

  ```
  项目目录
  ├── 用户项目_1
  ├── 用户项目_2
  └── CV_WEB
  ```

  如此，系统就将能够区分并接管两个用户项目 `用户项目_1` 和 `用户项目_2`。

- **任务**：任务没有具体的文件表示，而是逻辑上的步骤，是策略的调度与执行。例如：用户进行  ` 数据预处理` 任务，实际上需要经过 `数据裁剪`、`数据二值化` 等步骤，  ` 数据预处理` 是一个抽象的逻辑步骤，它本身实际上只有一个名字属性，以便用户在逻辑上整理和划分自己的项目工作。同时， `数据裁剪`、`数据二值化` 等步骤是具体的执行方式，它们便是 `策略`，`策略` 的修改和选择并不影响任务的逻辑性质（除非用户对任务的逻辑定义脱离了其真实执行的目的），用户可以选择各种合适的 `策略` 来完成任务。

- **策略**：策略指定了执行方式，是将逻辑上的某个特定任务步骤链接到具体对应的程序段的定向。由于程序段的高度多样性，策略拥有更复杂的约定以便于系统接管。策略与策略文件和策略函数有关，我们将在用户文件说明中详细展示它们的关系。

#### 3.2.3.三种用户文件

​	为了便于兼顾 Linux 平台和遵守透明化模块化的管理方式，平台的一切操作对象皆为文件，主要分为资源文件、策略文件和配置文件：

- **配置文件**：配置文件必须是 `.json` 格式的字典。配置文件指定了对应策略的各个超参数的值。

- **策略文件**：策略文件必须是 `.py` 的脚本文件。策略文件中包含许多函数，但并不是所有函数都是策略函数，只有符合协议的函数才是”规范的“，规范的函数可以成为策略函数：

  - 策略函数的所有参数内容，只能被从配置文件中的配置项指定，或由同一个任务中具有直接前驱关系的函数的输出提供。
  - 策略函数的输出，要么一定会被用一个任务中具有直接后继关系的函数的参数接受，要么在函数内部写入外存。
  - 策略函数内部可以调用普通函数，或策略函数，或做任何事情，但函数内部的任何行为都不会直接被系统察觉，用户需要自行管理安全性等问题。

  策略函数可以被看做一个策略的入口函数，一旦这个函数被调用则代表一个策略被开始执行了。

  一个函数被称为策略函数意味着它满足了策略函数的约定，但是只有当用户将策略函数注册后，才能被系统识别为策略，只有策略可以被系统接管。

- **资源文件**：除了配置文件与策略文件以外的一切项目文件被视作资源文件。需要注意的是，系统提供了对所有用户文件的渲染支持，即用户可以在前端查看文件，但是配置文件和策略文件被规定了文件格式，相当于隐含指定了渲染方式。而资源文件是自由格式的，这意味着系统只能在一定程度上支持一些常见格式的渲染，不支持的格式应该被经过策略加工后，转为常见格式才能被前端渲染，同时前端支持一些基础的展示选择与工具。

#### 3.2.4.系统调度框架

​	CV-WEB 采用 `项目-任务-策略` 三级调度框架。

​	系统管理用户的所有项目，为每个项目创建一个线程（采用多线程而非多进程管理任务的主要原因是便于同步系统对象）。

​	在项目中，任务之间只能被串行调度，系统会根据收到的消息顺序执行对应的任务。

​	对于每个任务，系统支持顺序执行或迭代顺序执行其中的策略。具体来说，当用户将任务类型设置为“非迭代型”（请求体对应的 `ITER` 置假），系统会按顺序执行各策略然后结束；对于“迭代型”（请求体对应的 `ITER` 置真），则会将本任务的第一个策略视作“迭代器对象实例化函数”（其具体的协议内容见下一节策略协议）并迭代执行第二到最后一个策略。

​	策略执行请求体样例，其中大写的都是系统保留字：

```json
{
    "test_project": {
        "add_sub":{
            "STRATEGY_QUEUE":[
                {
                    "ID":"strategy_1",
                    "FUNC":"add",
                    "ARGS": {
                        "a":"num1",
                        "b":"num2"
                    }
                },
                {
                    "ID":"strategy_2",
                    "FUNC":"sub",
                    "ARGS": {
                        "a":"strategy_1_OUTPUT",
                        "b":"num1"
                    }
                }
            ],
            "ITER":false
        }
    }
}
```

```json
{
    "test_project": {
        "add_sub_iter":{
            "STRATEGY_QUEUE":[
                {
                    "ID":"strategy_1",
                    "FUNC":"iter",
                    "ARGS": {
                        "num":"num3"
                    }
                },
                {
                    "ID":"strategy_2",
                    "FUNC":"sub",
                    "ARGS": {
                        "a":"ITER_TERM",
                        "b":"num1"
                    }
                }
            ],
            "ITER":true
        }
    }
}
```

#### 3.2.5.策略协议

​	只有遵守策略协议的函数才能被认为是策略函数，被用户注册后可以被正确调度。

1. 合法的输入源只能是以下对象：
   - 用户项目配置文件中的配置项
   - 同一任务中前驱策略的输出
   - 资源集
2. 策略函数的参数表只能传入合法输入源，或在函数定义中指定默认值
3. 策略的输出不会被序列解包，只能被整个接受



### 3.3.功能设计

![用例图](.figure/用例图.png)

#### 3.3.1.前端功能设计

前端功能主要分为三个系统：项目工作台、文件编辑器和数据渲染器

##### 主页面

展示用户各个项目的基本信息（包括项目名称，上次编辑时间，项目状态），用户可以选择进入某个项目的项目工作台

##### 项目工作台

项目工作台负责项目管理、任务管理和执行，具体功能包括：

- 在项目菜单栏中查看策略注册表（策略名，参数表，备注）
- 在项目菜单栏中选择配置文件路径，选择完成后会直接生成配置表块。
- 点击配置表块，或在项目菜单栏中查看配置表（配置项：配置值）
- 在项目菜单栏中选择创建任务块，选择任务类型（迭代/非迭代），不同类型的任务块有直观的 UI 区分，创建任务块时输入任务名字，可编辑
- 任务块上有执行控件，执行开始后可以强制停止
- 任务块中有添加策略控件（例如“+”），点击后可以添加策略注册表中的策略，以策略块的形式添加到控件前，任务块拉伸适应
- 策略块需要基于 GUI 显示：策略名，参数表，输出端
- 策略块参数表中的参数可以被点击，点击后进行对输入源的选择，选择输入源后会根据对应关系渲染连线，生成连线的颜色是唯一的。对某个策略，其输入源只能是：①配置表项；②已经被创建的资源集块；③同一个任务中前驱策略的输出
- 用户可以直接在界面上通过连线连接各种输入源到参数表，各连线的颜色可以被修改
- 当某一个任务块被执行，便处于执行队列的首位，其余被要求执行的任务块依次排队，队列是可见的，也可以从队列中删除某个未被执行的任务
- 在项目菜单栏中选择创建资源块，资源块的初始对应文件夹是空的，点击资源块选择文件目录进行对应，支持文件夹选择和文件批量选择。对资源块的配置在系统中会被置为：资源块名称：资源路径（文件夹或文件列表）并写入用户配置表，在任务执行前，应该先调用配置修改路由。因此对资源块的调用实际上是对配置文件的修改
- 拥有输出信息显示窗口，显示任务中的所有标准输出和错误信息
- 拥有系统资源监控显示窗口
- 在项目菜单中，可以浏览项目文件目录，双击文件，如果是 `.py` 或 `.json` 文件将由文本编辑器接管，否则由数据渲染器接管。文件目录本身支持修改，包括：创建文件夹，创建文件，重命名文件或文件夹，删除文件或文件夹

##### 文本编辑器

​	文本编辑器提供对`.py` 或 `.json` 文件的在线展示和修改，它是项目工作台的子窗口

##### 数据渲染器

​	数据渲染器对非文本对象进行处理，主要包括：

- 从文件目录中直接点击进行查看，此时数据格式应当是常见的二维或三维数据格式，否则前端不支持打开
- 对于非默认支持格式，系统策略提供专门的策略进行数据发前端。具体来说，用户应先在项目工作台中建立数据块，选择要展示的数据，建立任务，任务中包含用户的渲染策略，并以系统提供的专用策略作为任务的最后一个策略，这个系统策略会将进过处理的数据发前端，以被支持渲染。当然，事实上用户也可以通过单纯的一个发前端策略组成的任务对前端支持格式的数据进行查看，这显然是支持的，只是我们在前端提供了更简单的直接查看方法
- 在数据渲染器中，对于二维数据支持常规查看操作（缩放，平移）（暂时不做修改，也先不做三维数据）
- 需要说明的是，无论前端进行的是什么操作，查看数据的方式最终都是经过布置任务的模式，只是对于原生支持数据来说，这个过程是系统隐式地进行的，但 API 是一样的



### 3.4.模块设计

#### 3.4.1.系统的分层结构

​	从总体上来看，系统分为五层。自底向上看：

- 用户文件：用户的项目组成。用户文件以及其中的部分内容需要遵守协议才能与系统对接。用户文件对上层不完全是透明的，对于资源文件和配置文件管理层拥有一切必要信息的知情权；而对于策略文件，需要用户通过注册函数入口的方式提供管理层策略调度接口，而策略的实现是透明的。
- 管理层：对下层而言，管理层对用户文件进行管理；对上层而言提供相应的接口。管理层主要与深度学习框架协同完成用户任务，对操作层是透明的。管理层相当于用户任务与系统任务的过渡，降低任务之间的耦合度。
- 数据库：数据库属于系统资源，主要用于维护用户信息和项目现场，用户文件内容不会被数据库保存。
- 操作层：基于 Java 的系统业务管理层，负责接受前端的请求并执行响应。操作层不会进入深度学习框架直接参与用户任务，而是通过调用管理层的接口调度各项事务的有序进行。
- 表示层：基于 WEB UI 开发的可视交互界面。

<img src=".figure/3.png" alt="3" style="zoom:50%;" />

​	借助分层结构可以进一步说明系统的任务逻辑：在用户任务的基础上，系统允许用户通过系统任务来间接地执行和管理用户任务，实现对用户任务的上层接管。

​	在此基础上，进一步给出层内模块关系：

<img src=".figure/4.png" alt="4" style="zoom: 50%;" />

​	从层内模块关系也可以看出，用户文件与管理层的耦合度是较高的，这是管理层的介入性质。而管理层与操作层、操作层与表示层之间都通过唯一的控制端进行通信。

### 操作层模块设计

操作层作为系统的中间层，负责接收前端的请求并调度管理层完成相应的操作。

#### 操作层主控端

**功能**：

- 接收并解析前端的请求，包括但不限于预处理请求、训练请求和推理请求。
- 根据请求类型，调度相应的模块进行处理。
- 接收模块返回的结果并转发给前端。

**设计**：

- 前端发起请求，请求可能包括预处理请求、训练请求和推理请求等。
- 操作层主控端接收并解析请求，确定请求类型。
- 根据请求类型，调度相应的模块进行处理。例如，如果是预处理请求，则调度数据预处理模块进行处理。
- 接收模块返回的结果并转发给前端。

### 管理层模块设计

管理层作为系统的核心，负责介入用户任务，管理用户文件和提供调度接口。

#### 管理层主控端

**功能**：

- 接收并解析操作层的请求，包括但不限于配置文件处理请求、资源文件处理请求和策略文件处理请求。
- 根据请求类型，调度相应的模块进行处理。
- 接收模块返回的结果并转发给操作层。

**设计**：

- 操作层发起请求，请求可能包括配置文件处理请求、资源文件处理请求和策略文件处理请求等。
- 管理层主控端接收并解析请求，确定请求类型。
- 根据请求类型，调度相应的模块进行处理。例如，如果是配置文件处理请求，则调度配置文件管理器进行处理。
- 接收模块返回的结果并转发给操作层。

#### 配置文件管理器

**功能**：

- 响应操作层的配置文件处理请求，接受操作层发送的配置文件路径等信息。
- 读取和解析配置文件，提供配置文件的修改和保存功能。

**设计**：

- 操作层发起配置文件处理请求，请求中包含配置文件路径等信息。
- 配置文件管理器接收请求，读取指定路径的配置文件并解析内容。
- 返回解析后的配置文件内容给操作层。
- 接收操作层的配置修改请求，更新配置文件并保存。

#### 资源文件管理器

**功能**：

- 响应操作层的资源文件处理请求，接受操作层发送的资源文件路径等信息。
- 读取和管理资源文件，提供资源文件的访问和修改功能。

**设计**：

- 操作层发起资源文件处理请求，请求中包含资源文件路径等信息。
- 资源文件管理器接收请求，读取指定路径的资源文件。
- 返回资源文件内容给操作层。
- 接收操作层的资源修改请求，更新资源文件并保存。

#### 策略文件管理器

**功能**：

- 响应操作层的策略文件处理请求，接受操作层发送的策略文件路径等信息。
- 读取和管理策略文件，提供策略文件的注册和调用功能。

**设计**：

- 操作层发起策略文件处理请求，请求中包含策略文件路径等信息。
- 策略文件管理器接收请求，读取指定路径的策略文件并注册策略。
- 返回策略注册表给操作层。
- 接收操作层的策略调用请求，执行相应策略并返回结果。

![seq](.figure/seq.png)

### 数据库模块设计

数据库和操作层、管理层直接连接，实现登录验证、任务信息存储、项目及成员管理等功能

**功能**：

* 实现登录验证
* 存储任务信息(留档)
* 项目及成员管理

**设计**：

* 数据库和操作层、管理层分别直接连接
* 登录的时候表示层把登录表单发到操作层，操作层拿着表单去数据库中查询用户信息，判断用户是否可以登录，可以登录的话发放令牌
* 用户创建项目，向数据库中插入项目信息，同时插入项目成员信息
* 用户可以拉其他用户到项目中，对应地更新项目成员表
* 项目状态在项目信息表中维护


## 详细设计

### 数据库

#### 表设计

| 表名       | 属性                            | 备注               |
| ---------- | ------------------------------- | ------------------ |
| user_info  | uno, key                        | 用户信息表         |
| user_proj  | uno, pno                        | 用户项目表         |
| proj_info  | proj, last_modify_time, pstatus | 项目信息表         |
| proj_conf  | pno, cpath                      | 项目配置文件路径表 |
| proj_scene | pno,***                         | 项目现场表         |

备注：

- 





SQL

#### 登录信息表

* 账户id(主键)
* 账户密码(SHA256+加盐 加密)

类型如下：
```sql
CREATE TABLE users(
  user_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
  user_password char(64) NOT NULL
)AUTO_INCREMENT=100000000 DEFAULT CHARSET=utf8mb4;
```
